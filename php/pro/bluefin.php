<?php

namespace ccxt\pro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \React\Async;
use \React\Promise\PromiseInterface;

class bluefin extends \ccxt\async\bluefin {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'has' => array(
                'ws' => true,
                'watchOrderBook' => true,
                'watchTicker' => true,
                'watchTickers' => true,
                'watchTrades' => true,
                'watchOHLCV' => true,
                'watchOrders' => true,
                'watchMyTrades' => true,
                'watchBalance' => true,
                'watchPositions' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => array(
                        'public' => 'wss://stream.api.sui-prod.bluefin.io/ws/market',
                        'private' => 'wss://stream.api.sui-prod.bluefin.io/ws/account',
                    ),
                ),
                'test' => array(
                    'ws' => array(
                        'public' => 'wss://stream.api.sui-staging.bluefin.io/ws/market',
                        'private' => 'wss://stream.api.sui-staging.bluefin.io/ws/account',
                    ),
                ),
            ),
            'streaming' => array(
                'ping' => array($this, 'ping'),
                'keepAlive' => 20000,
            ),
        ));
    }

    public function watch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            // TODO:
            //  1. loadMarkets, resolve market
            //  2. Subscribe to channel => "Partial_Depth_20" or "Diff_Depth_500_ms"
            //     on the public (market) WS
            //  3. Subscription message:
            //     { op => "SUBSCRIBE", channel => "Partial_Depth_20",
            //       symbols => array( bluefinSymbol ) }
            //  4. messageHash = 'orderbook:' . $symbol
            //  5. return Async\await($this->watch(url, messageHash, message, messageHash)
            throw new \Exception('watchOrderBook not implemented'));
        }) ();
    }

    public function watch_ticker(string $symbol, $params = array ()): PromiseInterface {
        // TODO => subscribe to "Ticker" channel on market WS
        //       messageHash = 'ticker:' . $symbol
        throw new \Exception('watchTicker not implemented');
    }

    public function watch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        // TODO => subscribe to "Ticker_All" channel on market WS
        //       messageHash = 'tickers'
        throw new \Exception('watchTickers not implemented');
    }

    public function watch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        // TODO => subscribe to "Recent_Trade" channel on market WS
        //       messageHash = 'trades:' . $symbol
        throw new \Exception('watchTrades not implemented');
    }

    public function watch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        // TODO => subscribe to "Candlestick_{interval}_Last" channel
        //       where interval = $this->timeframes[$timeframe]
        //       messageHash = 'ohlcv:' . $timeframe . ':' . $symbol
        throw new \Exception('watchOHLCV not implemented');
    }

    public function watch_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        // TODO:
        //  1. Authenticate if needed (getAccessToken)
        //  2. Subscribe to "AccountOrderUpdate" on account WS
        //  3. Subscription message includes authToken field:
        //     { op => "SUBSCRIBE", channel => "AccountOrderUpdate",
        //       authToken => $this->jwt}
        //  4. messageHash = 'orders'
        throw new \Exception('watchOrders not implemented');
    }

    public function watch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        // TODO => subscribe to "AccountTradeUpdate" on account WS
        //       with authToken, messageHash = 'myTrades'
        throw new \Exception('watchMyTrades not implemented');
    }

    public function watch_balance($params = array ()): PromiseInterface {
        // TODO => subscribe to "AccountUpdate" on account WS
        //       with authToken, messageHash = 'balance'
        throw new \Exception('watchBalance not implemented');
    }

    public function watch_positions(?array $symbols = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        // TODO => subscribe to "AccountPositionUpdate" on account WS
        //       with authToken, messageHash = 'positions'
        throw new \Exception('watchPositions not implemented');
    }

    public function handle_message(Client $client, mixed $message): void {
        // TODO => route by channel/event type in the incoming $message->
        //
        // Expected dispatch table ($message->channel → $handler):
        //   "OrderbookPartialDepthUpdate"  → handleOrderBook
        //   "OrderbookDiffDepthUpdate"     → handleOrderBook
        //   "TickerUpdate"                 → handleTicker
        //   "RecentTradesUpdates"          → handleTrades
        //   "CandlestickUpdate"            → handleOHLCV
        //   "AccountOrderUpdate"           → handleOrder
        //   "AccountTradeUpdate"           → handleMyTrades
        //   "AccountUpdate"                → handleBalance
        //   "AccountPositionUpdate"        → handlePosition
        //   "pong"                         → handlePong
        //
        // $methods = array(
        //     'OrderbookPartialDepthUpdate' => array($this, 'handle_order_book'),
        //     'OrderbookDiffDepthUpdate' => array($this, 'handle_order_book'),
        //     'TickerUpdate' => array($this, 'handle_ticker'),
        //     'RecentTradesUpdates' => array($this, 'handle_trades'),
        //     'CandlestickUpdate' => array($this, 'handle_ohlcv'),
        //     'AccountOrderUpdate' => array($this, 'handle_order'),
        //     'AccountTradeUpdate' => array($this, 'handle_my_trades'),
        //     'AccountUpdate' => array($this, 'handle_balance'),
        //     'AccountPositionUpdate' => array($this, 'handle_position'),
        //     'pong' => array($this, 'handle_pong'),
        // );
        // $channel = $this->safe_string($message, 'channel');
        // $handler = $this->safe_value($methods, $channel);
        // if ($handler !== null) {
        //     $handler($client, $message);
        // }
    }

    public function handle_order_book(Client $client, array $message): void {
        // TODO => parse OrderbookPartialDepthUpdate / OrderbookDiffDepthUpdate
        //  - Extract symbol, bids, asks from $message->data
        //  - For partial = 'orderbook:' . symbol
    }

    public function handle_ticker(Client $client, array $message): void {
        // TODO => parse TickerUpdate
        //  - Extract ticker data from $message->data
        //  - Parse via $this->parse_ticker()
        //  - Resolve messageHash = 'ticker:' . symbol
    }

    public function handle_trades(Client $client, array $message): void {
        // TODO => parse RecentTradesUpdates
        //  - Extract trades array from $message->data
        //  - Parse each via $this->parse_trade()
        //  - Append to ArrayCache
        //  - Resolve messageHash = 'trades:' . symbol
    }

    public function handle_ohlcv(Client $client, array $message): void {
        // TODO => parse CandlestickUpdate
        //  - Extract candle from $message->data
        //  - Parse via $this->parse_ohlcv()
        //  - Append to ArrayCacheByTimestamp
        //  - Resolve messageHash = 'ohlcv:' . timeframe . ':' . symbol
    }

    public function handle_order(Client $client, array $message): void {
        // TODO => parse AccountOrderUpdate
        //  - Parse via $this->parse_order()
        //  - Update ArrayCacheBySymbolById
        //  - Resolve messageHash = 'orders'
    }

    public function handle_my_trades(Client $client, array $message): void {
        // TODO => parse AccountTradeUpdate
        //  - Parse via $this->parse_trade()
        //  - Append to ArrayCache
        //  - Resolve messageHash = 'myTrades'
    }

    public function handle_balance(Client $client, array $message): void {
        // TODO => parse AccountUpdate
        //  - Parse via $this->parse_balance()
        //  - Resolve messageHash = 'balance'
    }

    public function handle_position(Client $client, array $message): void {
        // TODO => parse AccountPositionUpdate
        //  - Parse via $this->parse_position()
        //  - Resolve messageHash = 'positions'
    }

    public function ping(Client $client): array {
        return array( 'op' => 'PING' );
    }

    public function handle_pong(Client $client, mixed $message): void {
        $client->lastPong = $this->milliseconds();
    }
}
