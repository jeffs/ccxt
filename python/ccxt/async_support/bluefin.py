# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.async_support.base.exchange import Exchange
from ccxt.abstract.bluefin import ImplicitAPI
from ccxt.base.types import Any, Balances, Int, Market, Num, Order, OrderBook, OrderSide, OrderType, Position, Str, Strings, Ticker, Tickers, Trade, FundingRateHistory
from typing import List
from ccxt.base.decimal_to_precision import TICK_SIZE
from ccxt.base.precise import Precise


class bluefin(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(bluefin, self).describe(), {
            'id': 'bluefin',
            'name': 'Bluefin',
            'countries': ['SG'],
            'version': 'v1',
            'rateLimit': 100,
            'certified': False,
            'pro': True,
            'dex': True,
            'requiredCredentials': {
                'apiKey': False,
                'secret': False,
                'walletAddress': True,  # Sui Ed25519 address
                'privateKey': True,  # Ed25519 private key
            },
            'has': {
                'CORS': None,
                'spot': False,
                'margin': False,
                'swap': True,
                'future': False,
                'option': False,
                'addMargin': True,
                'cancelOrder': True,
                'cancelOrders': True,
                'createOrder': True,
                'fetchBalance': True,
                'fetchFundingRateHistory': True,
                'fetchMarkets': True,
                'fetchMyTrades': True,
                'fetchOHLCV': True,
                'fetchOpenOrders': True,
                'fetchOrderBook': True,
                'fetchPositions': True,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'reduceMargin': True,
                'setLeverage': True,
                'setMarginMode': True,
                'withdraw': True,
            },
            'timeframes': {
                '1m': '1m',
                '3m': '3m',
                '5m': '5m',
                '15m': '15m',
                '30m': '30m',
                '1h': '1h',
                '2h': '2h',
                '4h': '4h',
                '6h': '6h',
                '8h': '8h',
                '12h': '12h',
                '1d': '1d',
                '3d': '3d',
                '1w': '1w',
                '1M': '1Mo',
            },
            'urls': {
                'logo': 'https://bluefin.io/logo.svg',
                'api': {
                    'auth': 'https://auth.api.sui-prod.bluefin.io',
                    'exchange': 'https://api.sui-prod.bluefin.io',
                    'account': 'https://api.sui-prod.bluefin.io',
                    'trade': 'https://trade.api.sui-prod.bluefin.io',
                },
                'test': {
                    'auth': 'https://auth.api.sui-staging.bluefin.io',
                    'exchange': 'https://api.sui-staging.bluefin.io',
                    'account': 'https://api.sui-staging.bluefin.io',
                    'trade': 'https://trade.api.sui-staging.bluefin.io',
                },
                'www': 'https://bluefin.io',
                'doc': [
                    'https://bluefin-exchange.readme.io/reference',
                ],
                'fees': 'https://docs.bluefin.io/fees',
            },
            'api': {
                'exchange': {
                    'get': [
                        'v1/exchange/info',
                        'v1/exchange/depth',
                        'v1/exchange/ticker',
                        'v1/exchange/tickers',
                        'v1/exchange/trades',
                        'v1/exchange/candlesticks',
                        'v1/exchange/fundingRateHistory',
                    ],
                },
                'auth': {
                    'post': [
                        'auth/token',
                        'auth/v2/token',
                    ],
                    'put': [
                        'auth/token/refresh',
                    ],
                },
                'account': {
                    'get': [
                        'api/v1/account',
                        'api/v1/account/trades',
                        'api/v1/account/transactions',
                        'api/v1/account/fundingRateHistory',
                        'api/v1/trade/openOrders',
                        'api/v1/trade/standbyOrders',
                    ],
                },
                'trade': {
                    'post': [
                        'api/v1/trade/orders',
                        'api/v1/trade/withdraw',
                    ],
                    'put': [
                        'api/v1/trade/orders/cancel',
                        'api/v1/trade/leverage',
                        'api/v1/trade/adjustIsolatedMargin',
                    ],
                },
            },
            'fees': {
                'swap': {
                    'maker': 0.0002,  # 2 bps
                    'taker': 0.0005,  # 5 bps
                },
            },
            'precisionMode': TICK_SIZE,
            'options': {
                'defaultType': 'swap',
                'sandboxMode': False,
            },
        })

    async def fetch_markets(self, params={}) -> List[Market]:
        response = await self.exchangeGetV1ExchangeInfo(params)
        markets = self.safe_list(response, 'markets', [])
        result: List[Market] = []
        for i in range(0, len(markets)):
            result.append(self.parse_market(markets[i]))
        return result

    async def fetch_ticker(self, symbol: str, params={}) -> Ticker:
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': self.bluefin_symbol(symbol),
        }
        response = await self.exchangeGetV1ExchangeTicker(self.extend(request, params))
        return self.parse_ticker(response, market)

    async def fetch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        await self.load_markets()
        response = await self.exchangeGetV1ExchangeTickers(params)
        result: Tickers = {}
        for i in range(0, len(response)):
            ticker = self.parse_ticker(response[i])
            symbol = ticker['symbol']
            if symbols is not None and not self.in_array(symbol, symbols):
                continue
            result[symbol] = ticker
        return result

    async def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        request: dict = {
            'symbol': symbol.replace('/USDC:USDC', '-PERP'),
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.exchangeGetV1ExchangeDepth(self.extend(request, params))
        timestamp = self.safe_integer(response, 'updatedAtMillis')
        nonce = self.safe_integer(response, 'lastUpdateId')
        # bidsE9/asksE9 are arrays of [priceE9, qtyE9] strings
        # convert to plain floats before parseOrderBook.
        rawBids = self.safe_list(response, 'bidsE9', [])
        rawAsks = self.safe_list(response, 'asksE9', [])
        bids = self.convert_e9_levels(rawBids)
        asks = self.convert_e9_levels(rawAsks)
        orderbook = self.parse_order_book({'bids': bids, 'asks': asks}, symbol, timestamp, 'bids', 'asks', 0, 1)
        orderbook['nonce'] = nonce
        return orderbook

    async def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': self.bluefin_symbol(symbol),
        }
        if limit is not None:
            request['limit'] = limit
        response = await self.exchangeGetV1ExchangeTrades(self.extend(request, params))
        result: List[Trade] = []
        for i in range(0, len(response)):
            result.append(self.parse_trade(response[i], market))
        return result

    async def fetch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        await self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': self.bluefin_symbol(symbol),
            'interval': self.safe_string(self.timeframes, timeframe, timeframe),
        }
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = await self.exchangeGetV1ExchangeCandlesticks(self.extend(request, params))
        result: List[OHLCV] = []
        for i in range(0, len(response)):
            result.append(self.parse_ohlcv(response[i], market))
        return result

    async def fetch_funding_rate_history(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[FundingRateHistory]:
        request: dict = {}
        if symbol is not None:
            request['symbol'] = symbol.replace('/USDC:USDC', '-PERP')
        if since is not None:
            request['startTime'] = since
        if limit is not None:
            request['limit'] = limit
        response = await self.exchangeGetV1ExchangeFundingRateHistory(self.extend(request, params))
        result: List[FundingRateHistory] = []
        for i in range(0, len(response)):
            result.append(self.parse_funding_rate_history(response[i]))
        return result

    async def fetch_balance(self, params={}) -> Balances:
        # TODO: call accountGetApiV1Account(needs JWT),
        #       parse via parseBalance
        #
        # await self.load_markets()
        # response = await self.accountGetApiV1Account(params)
        # return self.parse_balance(response)
        raise Error('fetchBalance not implemented')

    async def fetch_positions(self, symbols: Strings = None, params={}) -> List[Position]:
        # TODO: call accountGetApiV1Account(needs JWT),
        #       extract positions array, parse each via parsePosition
        raise Error('fetchPositions not implemented')

    async def fetch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        # TODO: call accountGetApiV1AccountTrades(needs JWT),
        #       parse each via parseTrade
        raise Error('fetchMyTrades not implemented')

    async def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        # TODO: call accountGetApiV1TradeOpenOrders(needs JWT),
        #       parse each via parseOrder
        raise Error('fetchOpenOrders not implemented')

    async def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}) -> Order:
        # TODO:
        #  1. loadMarkets, resolve market
        #  2. Build signedFields:
        #     {market, price(E9), quantity(E9), leverage(E9),
        #       side: BUY/SELL, reduceOnly, salt, expiration, orderType}
        #  3. Sign fields with Ed25519 via signRequest()
        #  4. POST to tradePostApiV1TradeOrders with signed payload + JWT
        #  5. Parse response via parseOrder
        raise Error('createOrder not implemented')

    async def cancel_order(self, id: str, symbol: Str = None, params={}) -> Order:
        # TODO: build cancel payload with orderId(s),
        #       sign via signRequest, PUT to tradePutApiV1TradeOrdersCancel
        raise Error('cancelOrder not implemented')

    async def cancel_orders(self, ids: List[str], symbol: Str = None, params={}) -> List[Order]:
        # TODO: batch cancel — same endpoint, multiple orderIds
        raise Error('cancelOrders not implemented')

    async def set_leverage(self, leverage: Int, symbol: Str = None, params={}) -> Any:
        # TODO: build payload {symbol, leverageE9: toE9(leverage)},
        #       sign with signRequest, PUT to tradePutApiV1TradeLeverage
        raise Error('setLeverage not implemented')

    async def set_margin_mode(self, marginMode: str, symbol: Str = None, params={}) -> Any:
        # TODO: Bluefin sets margin mode via the leverage endpoint
        #       (isolated vs cross is a field on the leverage request)
        raise Error('setMarginMode not implemented')

    async def add_margin(self, symbol: str, amount: float, params={}) -> Any:
        # TODO: PUT to tradePutApiV1TradeAdjustIsolatedMargin
        #       with positive amount(E9)
        raise Error('addMargin not implemented')

    async def reduce_margin(self, symbol: str, amount: float, params={}) -> Any:
        # TODO: PUT to tradePutApiV1TradeAdjustIsolatedMargin
        #       with negative amount(E9)
        raise Error('reduceMargin not implemented')

    async def withdraw(self, code: str, amount: float, address: str, tag: Str = None, params={}) -> Any:
        # TODO: POST to tradePostApiV1TradeWithdraw, signed
        raise Error('withdraw not implemented')

    def parse_market(self, market: dict) -> Market:
        id = self.safe_string(market, 'symbol')
        base = self.safe_string(market, 'baseAssetSymbol')
        quote = 'USDC'
        settle = 'USDC'
        symbol = base + '/' + quote + ':' + settle
        status = self.safe_string(market, 'status')
        return self.safe_market_structure({
            'id': id,
            'symbol': symbol,
            'base': base,
            'quote': quote,
            'settle': settle,
            'baseId': base,
            'quoteId': quote,
            'settleId': settle,
            'type': 'swap',
            'spot': False,
            'margin': False,
            'swap': True,
            'future': False,
            'option': False,
            'contract': True,
            'linear': True,
            'inverse': False,
            'active': status == 'ACTIVE',
            'contractSize': self.parse_number('1'),
            'precision': {
                'price': self.parse_e9(self.safe_string(market, 'tickSizeE9')),
                'amount': self.parse_e9(self.safe_string(market, 'stepSizeE9')),
            },
            'limits': {
                'amount': {
                    'min': self.parse_e9(self.safe_string(market, 'minOrderQuantityE9')),
                    'max': self.parse_e9(self.safe_string(market, 'maxLimitOrderQuantityE9')),
                },
                'price': {
                    'min': self.parse_e9(self.safe_string(market, 'minOrderPriceE9')),
                    'max': self.parse_e9(self.safe_string(market, 'maxOrderPriceE9')),
                },
                'leverage': {
                    'min': self.parse_number('1'),
                    'max': self.parse_e9(self.safe_string(market, 'defaultLeverageE9')),
                },
            },
            'info': market,
        })

    def parse_ticker(self, ticker: dict, market: Market = None) -> Ticker:
        bluefinSym = self.safe_string(ticker, 'symbol')
        symbol = self.ccxt_symbol(bluefinSym) if (bluefinSym is not None) else None
        last = self.parse_e9(self.safe_string(ticker, 'lastPriceE9'))
        mark = self.parse_e9(self.safe_string(ticker, 'markPriceE9'))
        index = self.parse_e9(self.safe_string(ticker, 'oraclePriceE9'))
        high = self.parse_e9(self.safe_string(ticker, 'highPrice24hrE9'))
        low = self.parse_e9(self.safe_string(ticker, 'lowPrice24hrE9'))
        open = self.parse_e9(self.safe_string(ticker, 'openPrice24hrE9'))
        close = last
        bid = self.parse_e9(self.safe_string(ticker, 'bestBidPriceE9'))
        ask = self.parse_e9(self.safe_string(ticker, 'bestAskPriceE9'))
        bidVolume = self.parse_e9(self.safe_string(ticker, 'bestBidQuantityE9'))
        askVolume = self.parse_e9(self.safe_string(ticker, 'bestAskQuantityE9'))
        baseVolume = self.parse_e9(self.safe_string(ticker, 'volume24hrE9'))
        quoteVolume = self.parse_e9(self.safe_string(ticker, 'quoteVolume24hrE9'))
        change = self.parse_e9(self.safe_string(ticker, 'priceChange24hrE9'))
        percentRaw = self.parse_e9(self.safe_string(ticker, 'priceChangePercent24hrE9'))
        percentage = Precise.string_mul(percentRaw, '100')
        timestamp = self.safe_integer(ticker, 'lastTimeAtMillis')
        return self.safe_ticker({
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': high,
            'low': low,
            'bid': bid,
            'bidVolume': bidVolume,
            'ask': ask,
            'askVolume': askVolume,
            'vwap': None,
            'open': open,
            'close': close,
            'last': last,
            'previousClose': None,
            'change': change,
            'percentage': percentage,
            'average': None,
            'baseVolume': baseVolume,
            'quoteVolume': quoteVolume,
            'markPrice': mark,
            'indexPrice': index,
            'mark': mark,
            'index': index,
            'info': ticker,
        }, market)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        id = self.safe_string(trade, 'id')
        bluefinSym = self.safe_string(trade, 'symbol')
        symbol = self.ccxt_symbol(bluefinSym) if (bluefinSym is not None) else None
        price = self.parse_e9(self.safe_string(trade, 'priceE9'))
        amount = self.parse_e9(self.safe_string(trade, 'quantityE9'))
        cost = self.parse_e9(self.safe_string(trade, 'quoteQuantityE9'))
        side = self.parse_order_side(self.safe_string(trade, 'side'))
        timestamp = self.safe_integer(trade, 'executedAtMillis')
        return self.safe_trade({
            'id': id,
            'info': trade,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'symbol': symbol,
            'order': None,
            'type': None,
            'side': side,
            'takerOrMaker': None,
            'price': price,
            'amount': amount,
            'cost': cost,
            'fee': None,
        }, market)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        id = self.safe_string(order, 'orderHash')
        clientOrderId = self.safe_string(order, 'clientOrderId')
        bluefinSym = self.safe_string(order, 'symbol')
        symbol = self.ccxt_symbol(bluefinSym) if (bluefinSym is not None) else None
        rawType = self.safe_string_lower(order, 'type')
        side = self.parse_order_side(self.safe_string(order, 'side'))
        price = self.parse_e9(self.safe_string(order, 'priceE9'))
        amount = self.parse_e9(self.safe_string(order, 'quantityE9'))
        filled = self.parse_e9(self.safe_string(order, 'filledQuantityE9'))
        status = self.parse_order_status(self.safe_string(order, 'status'))
        timeInForce = self.safe_string(order, 'timeInForce')
        postOnly = self.safe_bool(order, 'postOnly')
        reduceOnly = self.safe_bool(order, 'reduceOnly')
        timestamp = self.safe_integer(order, 'orderTimeAtMillis')
        return self.safe_order({
            'id': id,
            'clientOrderId': clientOrderId,
            'info': order,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': None,
            'symbol': symbol,
            'type': rawType,
            'timeInForce': timeInForce,
            'postOnly': postOnly,
            'reduceOnly': reduceOnly,
            'side': side,
            'price': price,
            'amount': amount,
            'filled': filled,
            'remaining': None,
            'cost': None,
            'average': None,
            'status': status,
            'fee': None,
            'trades': None,
        }, market)

    def parse_position(self, position: dict, market: Market = None) -> Position:
        bluefinSym = self.safe_string(position, 'symbol')
        symbol = self.ccxt_symbol(bluefinSym) if (bluefinSym is not None) else None
        rawSide = self.safe_string(position, 'side')
        side = rawSide.lower() if (rawSide is not None) else None
        contracts = self.parse_e9(self.safe_string(position, 'sizeE9'))
        entryPrice = self.parse_e9(self.safe_string(position, 'avgEntryPriceE9'))
        markPrice = self.parse_e9(self.safe_string(position, 'markPriceE9'))
        liquidationPrice = self.parse_e9(self.safe_string(position, 'liquidationPriceE9'))
        notional = self.parse_e9(self.safe_string(position, 'notionalValueE9'))
        unrealizedPnl = self.parse_e9(self.safe_string(position, 'unrealizedPnlE9'))
        initialMargin = self.parse_e9(self.safe_string(position, 'marginRequiredE9'))
        maintenanceMargin = self.parse_e9(self.safe_string(position, 'maintenanceMarginE9'))
        leverage = self.parse_e9(self.safe_string(position, 'clientSetLeverageE9'))
        isIsolated = self.safe_bool(position, 'isIsolated')
        marginMode = 'isolated' if isIsolated else 'cross'
        collateral = self.parse_e9(self.safe_string(position, 'isolatedMarginE9'))
            if isIsolated else initialMargin
        timestamp = self.safe_integer(position, 'updatedAtMillis')
        return self.safe_position({
            'id': None,
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'contracts': contracts,
            'contractSize': None,
            'side': side,
            'notional': notional,
            'leverage': leverage,
            'unrealizedPnl': unrealizedPnl,
            'realizedPnl': None,
            'collateral': collateral,
            'entryPrice': entryPrice,
            'markPrice': markPrice,
            'liquidationPrice': liquidationPrice,
            'marginMode': marginMode,
            'hedged': None,
            'maintenanceMargin': maintenanceMargin,
            'maintenanceMarginPercentage': None,
            'initialMargin': initialMargin,
            'initialMarginPercentage': None,
            'marginRatio': None,
            'percentage': None,
            'stopLossPrice': None,
            'takeProfitPrice': None,
            'info': position,
        })

    def parse_balance(self, response: dict) -> Balances:
        result: dict = {'info': response}
        assets = self.safe_list(response, 'assets', [])
        for i in range(0, len(assets)):
            asset = assets[i]
            code = self.safe_string(asset, 'symbol')
            account = self.account()
            account['total'] = self.parse_e9(self.safe_string(asset, 'quantityE9'))
            account['free'] = self.parse_e9(self.safe_string(asset, 'effectiveBalanceE9'))
            result[code] = account
        return self.safe_balance(result)

    def parse_ohlcv(self, ohlcv: Any, market: Market = None) -> list:
        # Bluefin returns candlesticks of strings:
        #   [startTime, open, high, low, close, volume,
        #    endTime, quoteVolume, tradeCount]
        return [
            self.safe_integer(ohlcv, 0),
            self.safe_number(ohlcv, 1),
            self.safe_number(ohlcv, 2),
            self.safe_number(ohlcv, 3),
            self.safe_number(ohlcv, 4),
            self.safe_number(ohlcv, 5),
        ]

    def parse_funding_rate_history(self, entry: dict, market: Market = None) -> FundingRateHistory:
        bluefinSym = self.safe_string(entry, 'symbol')
        symbol = self.ccxt_symbol(bluefinSym) if (bluefinSym is not None) else None
        fundingRate = self.parse_e9(self.safe_string(entry, 'fundingRateE9'))
        timestamp = self.safe_integer(entry, 'fundingTimeAtMillis')
        return {
            'info': entry,
            'symbol': symbol,
            'fundingRate': self.parse_number(fundingRate),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
        }

    def parse_order_status(self, status: Str) -> str:
        statuses: dict = {
            'PENDING': 'open',
            'STANDBY': 'open',
            'OPEN': 'open',
            'PARTIAL_FILLED': 'open',
            'PARTIALLY_FILLED_OPEN': 'open',
            'FILLED': 'closed',
            'CANCELLED': 'canceled',
            'CANCELLING': 'canceled',
            'PARTIALLY_FILLED_CANCELED': 'canceled',
            'EXPIRED': 'canceled',
            'PARTIALLY_FILLED_EXPIRED': 'canceled',
            'REJECTED': 'rejected',
        }
        return self.safe_string(statuses, status, status)

    def parse_order_side(self, side: Str) -> str:
        sides: dict = {
            'LONG': 'buy',
            'SHORT': 'sell',
            'BUY': 'buy',
            'SELL': 'sell',
        }
        return self.safe_string(sides, side, side)

    def sign(self, path: str, api='public', method='GET', params: dict = {}, headers: Any = None, body: Any = None) -> dict:
        #
        # CCXT calls self for every HTTP request.  We attach auth headers
        # only for private API groups(account, trade).
        #
        url = self.urls['api'][api] + '/' + path
        if api == 'exchange' or api == 'auth':
            # Public endpoints — no auth header
            if method == 'GET':
                if params:
                    url += '?' + self.urlencode(params)
            else:
                headers = {'Content-Type': 'application/json'}
                body = self.json(params)
        else:
            # Private endpoints — attach JWT bearer token
            # TODO: call getAccessToken()(which may trigger
            #       authenticate() or refreshAccessToken())
            #
            # token = await self.get_access_token()
            headers = {
                'Content-Type': 'application/json',
                # 'Authorization': 'Bearer ' + token,
            }
            if method == 'GET':
                if params:
                    url += '?' + self.urlencode(params)
            else:
                body = self.json(params)
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    async def authenticate(self, params={}) -> dict:
        # TODO: Ed25519 login flow
        #
        #  1. Build LoginRequest:
        #     {userAddress, audience: 'bluefin', timestamp}
        #  2. Serialise and sign with Ed25519(self.privateKey)
        #     to produce a Sui personalMessage signature
        #  3. POST to authPostAuthV2Token with:
        #     {token: base64Signature, userAddress, audience, timestamp}
        #  4. Store response: self.accessToken, self.refreshToken,
        #     self.accessTokenExpiry, self.refreshTokenExpiry
        #  5. Return {accessToken, refreshToken}
        #
        raise Error('authenticate not implemented')

    async def refresh_access_token(self, params={}) -> dict:
        # TODO: call authPutAuthTokenRefresh with
        #       {refreshToken: self.refreshToken}
        #       Update stored tokens + expiry times
        raise Error('refreshAccessToken not implemented')

    async def get_access_token(self) -> str:
        # TODO:
        #  - If no access token → call authenticate()
        #  - If access token near expiry(< 60s) → call refreshAccessToken()
        #  - Return self.accessToken
        raise Error('getAccessToken not implemented')

    def sign_request(self, fields: dict) -> dict:
        # TODO: Ed25519 personal message signing for trade operations.
        #
        #  Used by createOrder, cancelOrder, setLeverage, withdraw, etc.
        #
        #  1. Deterministically serialise `fields`(sorted keys, specific
        #     Bluefin encoding — see SDK source)
        #  2. Sign with Ed25519 self.privateKey
        #  3. Return {...fields, signature: base64Signature, signer: walletAddress}
        #
        raise Error('signRequest not implemented')

    def parse_e9(self, value: Str) -> Str:
        # Bluefin stores prices/quantities strings
        # scaled by 1e9. Shift the decimal point 9 places right
        # via Precise — no floating-point arithmetic involved.
        if value is None:
            return None
        precise = Precise(value)
        precise.decimals = precise.decimals + 9
        precise.reduce()
        return str(precise)

    def to_e9(self, value: Str) -> Str:
        # Reverse of parseE9: shift decimal 9 places left to
        # produce Bluefin's scaled-integer string.
        if value is None:
            return None
        precise = Precise(value)
        precise.decimals = precise.decimals - 9
        precise.reduce()
        return str(precise)

    def convert_e9_levels(self, levels: List[Any]) -> List[List[Any]]:
        # Convert [[priceE9, qtyE9], ...] to [[price, qty], ...]
        # pairs for lossless order book construction.
        result: List[Any][] = []
        for i in range(0, len(levels)):
            level = levels[i]
            result.append([
                self.parse_e9(self.safe_string(level, 0)),
                self.parse_e9(self.safe_string(level, 1)),
            ])
        return result

    def bluefin_symbol(self, ccxtSymbol: str) -> str:
        # "ETH/USDC:USDC" → "ETH-PERP"
        market = self.market(ccxtSymbol)
        return market['base'] + '-PERP'

    def ccxt_symbol(self, bluefinSymbol: str) -> str:
        # "ETH-PERP" → "ETH/USDC:USDC"
        base = bluefinSymbol.replace('-PERP', '')
        return base + '/USDC:USDC'
