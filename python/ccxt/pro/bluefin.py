# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

import ccxt.async_support
from ccxt.async_support.base.ws.cache import ArrayCache, ArrayCacheBySymbolById, ArrayCacheByTimestamp
from ccxt.base.types import Any, Balances, Int, Order, OrderBook, Position, Str, Strings, Ticker, Tickers, Trade
from ccxt.async_support.base.ws.client import Client
from typing import List


class bluefin(ccxt.async_support.bluefin):

    def describe(self):
        return self.deep_extend(super(bluefin, self).describe(), {
            'has': {
                'ws': True,
                'watchOrderBook': True,
                'watchTicker': True,
                'watchTickers': True,
                'watchTrades': True,
                'watchOHLCV': True,
                'watchOrders': True,
                'watchMyTrades': True,
                'watchBalance': True,
                'watchPositions': True,
            },
            'urls': {
                'api': {
                    'ws': {
                        'public': 'wss://stream.api.sui-prod.bluefin.io/ws/market',
                        'private': 'wss://stream.api.sui-prod.bluefin.io/ws/account',
                    },
                },
                'test': {
                    'ws': {
                        'public': 'wss://stream.api.sui-staging.bluefin.io/ws/market',
                        'private': 'wss://stream.api.sui-staging.bluefin.io/ws/account',
                    },
                },
            },
            'streaming': {
                'ping': self.ping,
                'keepAlive': 20000,
            },
        })

    async def watch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        # TODO:
        #  1. loadMarkets, resolve market
        #  2. Subscribe to channel: "Partial_Depth_20" or "Diff_Depth_500_ms"
        #     on the public(market) WS
        #  3. Subscription message:
        #     {op: "SUBSCRIBE", channel: "Partial_Depth_20",
        #       symbols: [bluefinSymbol]}
        #  4. messageHash = 'orderbook:' + symbol
        #  5. return await self.watch(url, messageHash, message, messageHash)
        raise Error('watchOrderBook not implemented')

    async def watch_ticker(self, symbol: str, params={}) -> Ticker:
        # TODO: subscribe to "Ticker" channel on market WS
        #       messageHash = 'ticker:' + symbol
        raise Error('watchTicker not implemented')

    async def watch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        # TODO: subscribe to "Ticker_All" channel on market WS
        #       messageHash = 'tickers'
        raise Error('watchTickers not implemented')

    async def watch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        # TODO: subscribe to "Recent_Trade" channel on market WS
        #       messageHash = 'trades:' + symbol
        raise Error('watchTrades not implemented')

    async def watch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        # TODO: subscribe to "Candlestick_{interval}_Last" channel
        #       where interval = self.timeframes[timeframe]
        #       messageHash = 'ohlcv:' + timeframe + ':' + symbol
        raise Error('watchOHLCV not implemented')

    async def watch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        # TODO:
        #  1. Authenticate if needed(getAccessToken)
        #  2. Subscribe to "AccountOrderUpdate" on account WS
        #  3. Subscription message includes authToken field:
        #     {op: "SUBSCRIBE", channel: "AccountOrderUpdate",
        #       authToken: self.jwt}
        #  4. messageHash = 'orders'
        raise Error('watchOrders not implemented')

    async def watch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        # TODO: subscribe to "AccountTradeUpdate" on account WS
        #       with authToken, messageHash = 'myTrades'
        raise Error('watchMyTrades not implemented')

    async def watch_balance(self, params={}) -> Balances:
        # TODO: subscribe to "AccountUpdate" on account WS
        #       with authToken, messageHash = 'balance'
        raise Error('watchBalance not implemented')

    async def watch_positions(self, symbols: Strings = None, since: Int = None, limit: Int = None, params={}) -> List[Position]:
        # TODO: subscribe to "AccountPositionUpdate" on account WS
        #       with authToken, messageHash = 'positions'
        raise Error('watchPositions not implemented')

    def handle_message(self, client: Client, message: Any):
        return None

    def handle_order_book(self, client: Client, message: dict):
        # TODO: parse OrderbookPartialDepthUpdate / OrderbookDiffDepthUpdate
        #  - Extract symbol, bids, asks from message.data
        #  - For partial = 'orderbook:' + symbol
        pass

    def handle_ticker(self, client: Client, message: dict):
        # TODO: parse TickerUpdate
        #  - Extract ticker data from message.data
        #  - Parse via self.parse_ticker()
        #  - Resolve messageHash = 'ticker:' + symbol
        pass

    def handle_trades(self, client: Client, message: dict):
        # TODO: parse RecentTradesUpdates
        #  - Extract trades array from message.data
        #  - Parse each via self.parse_trade()
        #  - Append to ArrayCache
        #  - Resolve messageHash = 'trades:' + symbol
        pass

    def handle_ohlcv(self, client: Client, message: dict):
        # TODO: parse CandlestickUpdate
        #  - Extract candle from message.data
        #  - Parse via self.parse_ohlcv()
        #  - Append to ArrayCacheByTimestamp
        #  - Resolve messageHash = 'ohlcv:' + timeframe + ':' + symbol
        pass

    def handle_order(self, client: Client, message: dict):
        # TODO: parse AccountOrderUpdate
        #  - Parse via self.parse_order()
        #  - Update ArrayCacheBySymbolById
        #  - Resolve messageHash = 'orders'
        pass

    def handle_my_trades(self, client: Client, message: dict):
        # TODO: parse AccountTradeUpdate
        #  - Parse via self.parse_trade()
        #  - Append to ArrayCache
        #  - Resolve messageHash = 'myTrades'
        pass

    def handle_balance(self, client: Client, message: dict):
        # TODO: parse AccountUpdate
        #  - Parse via self.parse_balance()
        #  - Resolve messageHash = 'balance'
        pass

    def handle_position(self, client: Client, message: dict):
        # TODO: parse AccountPositionUpdate
        #  - Parse via self.parse_position()
        #  - Resolve messageHash = 'positions'
        pass

    def ping(self, client: Client) -> dict:
        return {'op': 'PING'}

    def handle_pong(self, client: Client, message: Any):
        client.lastPong = self.milliseconds()
