<?php

namespace ccxt\async;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use ccxt\async\abstract\bluefin as Exchange;
use ccxt\AuthenticationError;
use ccxt\ArgumentsRequired;
use ccxt\OrderNotFound;
use ccxt\Precise;
use \React\Async;
use \React\Promise\PromiseInterface;

class bluefin extends Exchange {

    public function describe() {
        return $this->deep_extend(parent::describe(), array(
            'id' => 'bluefin',
            'name' => 'Bluefin',
            'countries' => array( 'SG' ),
            'version' => 'v1',
            'rateLimit' => 100,
            'certified' => false,
            'pro' => true,
            'dex' => true,
            'requiredCredentials' => array(
                'apiKey' => false,
                'secret' => false,
                'walletAddress' => true, // Sui Ed25519 address
                'privateKey' => true, // Ed25519 private key
            ),
            'has' => array(
                'CORS' => null,
                'spot' => false,
                'margin' => false,
                'swap' => true,
                'future' => false,
                'option' => false,
                'addMargin' => true,
                'cancelOrder' => true,
                'cancelOrders' => true,
                'createOrder' => true,
                'fetchBalance' => true,
                'fetchClosedOrders' => true,
                'fetchFundingRateHistory' => true,
                'fetchLeverageTiers' => true,
                'fetchMarkets' => true,
                'fetchMyTrades' => true,
                'fetchOHLCV' => true,
                'fetchOpenOrders' => true,
                'fetchOrder' => true,
                'fetchOrderBook' => true,
                'fetchPositions' => true,
                'fetchTicker' => true,
                'fetchTickers' => true,
                'fetchTrades' => true,
                'reduceMargin' => true,
                'setLeverage' => true,
                'setMarginMode' => true,
                'withdraw' => true,
            ),
            'timeframes' => array(
                '1m' => '1m',
                '3m' => '3m',
                '5m' => '5m',
                '15m' => '15m',
                '30m' => '30m',
                '1h' => '1h',
                '2h' => '2h',
                '4h' => '4h',
                '6h' => '6h',
                '8h' => '8h',
                '12h' => '12h',
                '1d' => '1d',
                '3d' => '3d',
                '1w' => '1w',
                '1M' => '1Mo',
            ),
            'urls' => array(
                'logo' => 'https://bluefin.io/logo.svg',
                'api' => array(
                    'auth' => 'https://auth.api.sui-prod.bluefin.io',
                    'exchange' => 'https://api.sui-prod.bluefin.io',
                    'account' => 'https://api.sui-prod.bluefin.io',
                    'trade' => 'https://trade.api.sui-prod.bluefin.io',
                ),
                'test' => array(
                    'auth' => 'https://auth.api.sui-staging.bluefin.io',
                    'exchange' => 'https://api.sui-staging.bluefin.io',
                    'account' => 'https://api.sui-staging.bluefin.io',
                    'trade' => 'https://trade.api.sui-staging.bluefin.io',
                ),
                'www' => 'https://bluefin.io',
                'doc' => array(
                    'https://bluefin-exchange.readme.io/reference',
                ),
                'fees' => 'https://docs.bluefin.io/fees',
            ),
            'api' => array(
                'exchange' => array(
                    'get' => array(
                        'v1/exchange/info',
                        'v1/exchange/depth',
                        'v1/exchange/ticker',
                        'v1/exchange/tickers',
                        'v1/exchange/trades',
                        'v1/exchange/candlesticks',
                        'v1/exchange/fundingRateHistory',
                    ),
                ),
                'auth' => array(
                    'post' => array(
                        'auth/token',
                        'auth/v2/token',
                    ),
                    'put' => array(
                        'auth/token/refresh',
                    ),
                ),
                'account' => array(
                    'get' => array(
                        'api/v1/account',
                        'api/v1/account/trades',
                        'api/v1/account/transactions',
                        'api/v1/account/fundingRateHistory',
                    ),
                ),
                'trade' => array(
                    'get' => array(
                        'api/v1/trade/openOrders',
                        'api/v1/trade/standbyOrders',
                    ),
                    'post' => array(
                        'api/v1/trade/orders',
                        'api/v1/trade/withdraw',
                    ),
                    'put' => array(
                        'api/v1/trade/orders/cancel',
                        'api/v1/trade/leverage',
                        'api/v1/trade/adjustIsolatedMargin',
                    ),
                ),
            ),
            'fees' => array(
                'swap' => array(
                    'maker' => 0.0002, // 2 bps
                    'taker' => 0.0005, // 5 bps
                ),
            ),
            'precisionMode' => TICK_SIZE,
            'options' => array(
                'defaultType' => 'swap',
                'sandboxMode' => false,
            ),
        ));
    }

    public function bcs_serialize_bytes(mixed $data): mixed {
        // BCS encoding for a $byte vector => ULEB128 length prefix followed by raw bytes
        $remaining = count($data);
        $result = $this->base16_to_binary('');
        while ($remaining >= 0x80) {
            $byte = ($remaining & 0x7f) | 0x80;
            $result = $this->binary_concat($result, $this->number_to_be($byte, 1));
            $remaining >>= 7;
        }
        $result = $this->binary_concat($result, $this->number_to_be($remaining, 1));
        return $this->binary_concat($result, $data);
    }

    public function sui_sign_personal_message(mixed $message, string $privateKeyHex): string {
        $bcsMsg = $this->bcs_serialize_bytes($message);
        $intentPrefix = $this->base16_to_binary('030000');
        $intentMsg = $this->binary_concat($intentPrefix, $bcsMsg);
        $digest = $this->hash($intentMsg, 'blake2b256', 'binary');
        $keyBytes = $this->base16_to_binary(str_replace('0x', '', $privateKeyHex));
        $sig = base64_decode(eddsa ($digest, $keyBytes, 'ed25519'));
        $pubkey = $this->eddsa_public_key($keyBytes, 'ed25519');
        $flagByte = $this->base16_to_binary('00');
        $envelope = $this->binary_concat($flagByte, $sig, $pubkey);
        return $this->binary_to_base64($envelope);
    }

    public function json_pretty_print(array $data): string {
        // Pretty-printed JSON with 2-space indent, matching Bluefin SDK's toJson()
        $keys = is_array($data) ? array_keys($data) : array();
        $lines => stringarray() = array( '{' );
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            $value = $data[$key];
            $valueStr = null;
            if (gettype($value) === 'string') {
                $valueStr = '"' . $value . '"';
            } elseif (is_bool($value)) {
                $valueStr = $value ? 'true' : 'false';
            } else array(
                $valueStr = (string) $value;
            }
            $comma = ($i < strlen($keys) - 1) ? ',' : '';
            $lines[] = '  "' . $key . '" => ' . $valueStr . $comma;
        }
        $lines[] = ')';
        return implode('\n', $lines);
    }

    public function sign_trade_request(array $payload): string {
        $jsonStr = $this->json_pretty_print($payload);
        return $this->sui_sign_personal_message($this->encode($jsonStr), $this->privateKey);
    }

    public function authenticate($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            $this->check_required_credentials();
            $now = $this->milliseconds();
            $loginRequest = array(
                'accountAddress' => $this->walletAddress,
                'signedAtMillis' => $now,
                'audience' => 'api',
            );
            $loginJson = $this->json($loginRequest);
            $signature = $this->sui_sign_personal_message($this->encode($loginJson), $this->privateKey);
            $request = array(
                'accountAddress' => $loginRequest['accountAddress'],
                'signedAtMillis' => $loginRequest['signedAtMillis'],
                'audience' => $loginRequest['audience'],
                'payloadSignature' => $signature,
            );
            $response = Async\await($this->authPostAuthV2Token ($this->extend($request, $params)));
            $accessToken = $this->safe_string($response, 'accessToken');
            $refreshToken = $this->safe_string($response, 'refreshToken');
            $accessValidFor = $this->safe_number($response, 'accessTokenValidForSeconds', 300);
            $refreshValidFor = $this->safe_number($response, 'refreshTokenValidForSeconds', 2592000);
            if ($accessToken === null) {
                throw new AuthenticationError($this->id . ' authenticate() failed — no $accessToken in response');
            }
            $nowSeconds = $now / 1000;
            $this->options['accessToken'] = $accessToken;
            $this->options['refreshToken'] = $refreshToken;
            $this->options['tokenSetAtSeconds'] = $nowSeconds;
            $this->options['accessTokenValidForSeconds'] = $accessValidFor;
            $this->options['refreshTokenValidForSeconds'] = $refreshValidFor;
            return $response;
        }) ();
    }

    public function refresh_access_token($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            $refreshToken = $this->safe_string($this->options, 'refreshToken');
            if ($refreshToken === null) {
                return Async\await($this->authenticate($params));
            }
            $request = array(
                'refreshToken' => $refreshToken,
            );
            $response = Async\await($this->authPutAuthTokenRefresh ($this->extend($request, $params)));
            $accessToken = $this->safe_string($response, 'accessToken');
            $newRefreshToken = $this->safe_string($response, 'refreshToken');
            $accessValidFor = $this->safe_number($response, 'accessTokenValidForSeconds', 300);
            $refreshValidFor = $this->safe_number($response, 'refreshTokenValidForSeconds', 2592000);
            if ($accessToken === null) {
                throw new AuthenticationError($this->id . ' refreshAccessToken() failed — no $accessToken in response');
            }
            $nowSeconds = $this->milliseconds() / 1000;
            $this->options['accessToken'] = $accessToken;
            $this->options['refreshToken'] = $newRefreshToken;
            $this->options['tokenSetAtSeconds'] = $nowSeconds;
            $this->options['accessTokenValidForSeconds'] = $accessValidFor;
            $this->options['refreshTokenValidForSeconds'] = $refreshValidFor;
            return $response;
        }) ();
    }

    public function is_access_token_expired(): bool {
        $token = $this->safe_string($this->options, 'accessToken');
        $tokenSetAt = $this->safe_number($this->options, 'tokenSetAtSeconds');
        if ($token === null || $tokenSetAt === null) {
            return true;
        }
        $lifetime = $this->safe_number($this->options, 'accessTokenValidForSeconds', 300);
        $nowSeconds = $this->milliseconds() / 1000;
        // Refresh at 80% of $lifetime (matching SDK)
        return $nowSeconds >= ($tokenSetAt . $lifetime * 0.8);
    }

    public function is_refresh_token_valid(): bool {
        $refreshToken = $this->safe_string($this->options, 'refreshToken');
        $tokenSetAt = $this->safe_number($this->options, 'tokenSetAtSeconds');
        if ($refreshToken === null || $tokenSetAt === null) {
            return false;
        }
        $lifetime = $this->safe_number($this->options, 'refreshTokenValidForSeconds', 2592000);
        $nowSeconds = $this->milliseconds() / 1000;
        // 60 second safety buffer
        return $nowSeconds < ($tokenSetAt . $lifetime - 60);
    }

    public function get_access_token(): PromiseInterface {
        return Async\async(function ()  {
            $token = $this->safe_string($this->options, 'accessToken');
            if ($token === null) {
                Async\await($this->authenticate());
                return $this->options['accessToken'];
            }
            if ($this->is_access_token_expired()) {
                if ($this->is_refresh_token_valid()) {
                    Async\await($this->refresh_access_token());
                } else {
                    Async\await($this->authenticate());
                }
            }
            return $this->options['accessToken'];
        }) ();
    }

    public function generate_salt(): string {
        return (string) $this->microseconds();
    }

    public function fetch_markets($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            $response = Async\await($this->exchangeGetV1ExchangeInfo ($params));
            $markets = $this->safe_list($response, 'markets', array());
            $contractsConfig = $this->safe_dict($response, 'contractsConfig');
            if ($contractsConfig !== null) {
                $this->options['contractsConfig'] = $contractsConfig;
            }
            $result => Marketarray() = array();
            for ($i = 0; $i < count($markets); $i++) {
                $result[] = $this->parse_market($markets[$i]);
            }
            return $result;
        }) ();
    }

    public function fetch_ticker(string $symbol, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $this->bluefin_symbol($symbol),
            );
            $response = Async\await($this->exchangeGetV1ExchangeTicker ($this->extend($request, $params)));
            return $this->parse_ticker($response, $market);
        }) ();
    }

    public function fetch_tickers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->load_markets());
            $response = Async\await($this->exchangeGetV1ExchangeTickers ($params));
            $result => Tickers = array();
            for ($i = 0; $i < count($response); $i++) {
                $ticker = $this->parse_ticker($response[$i]);
                $symbol = $ticker['symbol'];
                if ($symbols !== null && !$this->in_array($symbol, $symbols)) {
                    continue;
                }
                $result[$symbol] = $ticker;
            }
            return $result;
        }) ();
    }

    public function fetch_order_book(string $symbol, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $limit, $params) {
            $request = array(
                'symbol' => str_replace('/USDC:USDC', '-PERP', $symbol),
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->exchangeGetV1ExchangeDepth ($this->extend($request, $params)));
            $timestamp = $this->safe_integer($response, 'updatedAtMillis');
            $nonce = $this->safe_integer($response, 'lastUpdateId');
            // bidsE9/asksE9 are arrays of [priceE9, qtyE9] strings;
            // convert to plain floats before parseOrderBook.
            $rawBids = $this->safe_list($response, 'bidsE9', array());
            $rawAsks = $this->safe_list($response, 'asksE9', array());
            $bids = $this->convert_e9_levels($rawBids);
            $asks = $this->convert_e9_levels($rawAsks);
            $orderbook = $this->parse_order_book(array( 'bids' => $bids, 'asks' => $asks ), $symbol, $timestamp, 'bids', 'asks', 0, 1);
            $orderbook['nonce'] = $nonce;
            return $orderbook;
        }) ();
    }

    public function fetch_trades(string $symbol, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $request = array(
                'symbol' => $this->bluefin_symbol($symbol),
            );
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->exchangeGetV1ExchangeTrades ($this->extend($request, $params)));
            $result => Tradearray() = array();
            for ($i = 0; $i < count($response); $i++) {
                $result[] = $this->parse_trade($response[$i], $market);
            }
            return $result;
        }) ();
    }

    public function fetch_ohlcv(string $symbol, $timeframe = '1m', ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $timeframe, $since, $limit, $params) {
            Async\await($this->load_markets());
            $market = $this->market($symbol);
            $price = $this->safe_string($params, 'price');
            $params = $this->omit($params, 'price');
            $typeMap = array( 'mark' => 'Market', 'index' => 'Oracle' );
            $candleType = $this->safe_string($typeMap, $price, 'Last');
            $request = array(
                'symbol' => $this->bluefin_symbol($symbol),
                'interval' => $this->safe_string($this->timeframes, $timeframe, $timeframe),
                'type' => $candleType,
            );
            if ($since !== null) {
                $request['startTimeAtMillis'] = $since;
            } else {
                // Bluefin paginates forward from the beginning of $market
                // history when startTimeAtMillis is omitted. Compute a
                // sensible default so callers get the most recent candles.
                $effectiveLimit = ($limit !== null) ? $limit : 50;
                $durationMs = $this->parse_timeframe($timeframe) * 1000;
                $request['startTimeAtMillis'] = $this->milliseconds() - $effectiveLimit * $durationMs;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->exchangeGetV1ExchangeCandlesticks ($this->extend($request, $params)));
            $result => OHLCVarray() = array();
            for ($i = 0; $i < count($response); $i++) {
                $result[] = $this->parse_ohlcv($response[$i], $market);
            }
            return $result;
        }) ();
    }

    public function fetch_funding_rate_history(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            $request = array();
            if ($symbol !== null) {
                $request['symbol'] = str_replace('/USDC:USDC', '-PERP', $symbol);
            }
            if ($since !== null) {
                $request['startTimeAtMillis'] = $since;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->exchangeGetV1ExchangeFundingRateHistory ($this->extend($request, $params)));
            $result => FundingRateHistoryarray() = array();
            for ($i = 0; $i < count($response); $i++) {
                $result[] = $this->parse_funding_rate_history($response[$i]);
            }
            return $result;
        }) ();
    }

    public function fetch_balance($params = array ()): PromiseInterface {
        return Async\async(function () use ($params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $response = Async\await($this->accountGetApiV1Account ($params));
            return $this->parse_balance($response);
        }) ();
    }

    public function fetch_positions(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $response = Async\await($this->accountGetApiV1Account ($params));
            $positions = $this->safe_list($response, 'positions', array());
            $result => Positionarray() = array();
            for ($i = 0; $i < count($positions); $i++) {
                $position = $this->parse_position($positions[$i]);
                if ($symbols !== null && !$this->in_array($position['symbol'], $symbols)) {
                    continue;
                }
                $result[] = $position;
            }
            return $result;
        }) ();
    }

    public function fetch_my_trades(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $request = array();
            if ($symbol !== null) {
                $request['symbol'] = $this->bluefin_symbol($symbol);
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->accountGetApiV1AccountTrades ($this->extend($request, $params)));
            $market = ($symbol !== null) ? $this->market($symbol) : null;
            $result => Tradearray() = array();
            $trades = (gettype($response) === 'array' && array_keys($response) === array_keys(array_keys($response))) ? $response : $this->safe_list($response, 'trades', array());
            for ($i = 0; $i < count($trades); $i++) {
                $result[] = $this->parse_trade($trades[$i], $market);
            }
            return $result;
        }) ();
    }

    public function fetch_open_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $request = array();
            if ($symbol !== null) {
                $request['symbol'] = $this->bluefin_symbol($symbol);
            }
            $response = Async\await($this->tradeGetApiV1TradeOpenOrders ($this->extend($request, $params)));
            $market = ($symbol !== null) ? $this->market($symbol) : null;
            $orders = (gettype($response) === 'array' && array_keys($response) === array_keys(array_keys($response))) ? $response : $this->safe_list($response, 'orders', array());
            $result => Orderarray() = array();
            for ($i = 0; $i < count($orders); $i++) {
                $result[] = $this->parse_order($orders[$i], $market);
            }
            return $result;
        }) ();
    }

    public function fetch_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            // Bluefin has no individual order lookup endpoint.
            // Strategy => check $openOrders → $standbyOrders → reconstruct from $trades->
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $this->bluefin_symbol($symbol);
            }
            // 1. Search open orders
            $openResponse = Async\await($this->tradeGetApiV1TradeOpenOrders ($this->extend($request, $params)));
            $openOrders = (gettype($openResponse) === 'array' && array_keys($openResponse) === array_keys(array_keys($openResponse))) ? $openResponse : $this->safe_list($openResponse, 'orders', array());
            for ($i = 0; $i < count($openOrders); $i++) {
                if ($this->safe_string($openOrders[$i], 'orderHash') === $id) {
                    return $this->parse_order($openOrders[$i], $market);
                }
            }
            // 2. Search standby orders (conditional/trigger orders)
            $standbyResponse = Async\await($this->tradeGetApiV1TradeStandbyOrders ($this->extend($request, $params)));
            $standbyOrders = (gettype($standbyResponse) === 'array' && array_keys($standbyResponse) === array_keys(array_keys($standbyResponse))) ? $standbyResponse : $this->safe_list($standbyResponse, 'orders', array());
            for ($i = 0; $i < count($standbyOrders); $i++) {
                if ($this->safe_string($standbyOrders[$i], 'orderHash') === $id) {
                    return $this->parse_order($standbyOrders[$i], $market);
                }
            }
            // 3. Reconstruct from $trades (order was filled/closed)
            $tradeRequest = array();
            if ($symbol !== null) {
                $tradeRequest['symbol'] = $this->bluefin_symbol($symbol);
            }
            $tradeResponse = Async\await($this->accountGetApiV1AccountTrades ($this->extend($tradeRequest, $params)));
            $trades = (gettype($tradeResponse) === 'array' && array_keys($tradeResponse) === array_keys(array_keys($tradeResponse))) ? $tradeResponse : $this->safe_list($tradeResponse, 'trades', array());
            $matchingTrades => Dictarray() = array();
            for ($i = 0; $i < count($trades); $i++) {
                if ($this->safe_string($trades[$i], 'orderHash') === $id) {
                    $matchingTrades[] = $trades[$i];
                }
            }
            if (strlen($matchingTrades) > 0) {
                return $this->reconstruct_order_from_trades($id, $matchingTrades, $market);
            }
            throw new OrderNotFound($this->id . ' fetchOrder() order ' . $id . ' not found');
        }) ();
    }

    public function fetch_closed_orders(?string $symbol = null, ?int $since = null, ?int $limit = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $since, $limit, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $request = array();
            $market = null;
            if ($symbol !== null) {
                $market = $this->market($symbol);
                $request['symbol'] = $this->bluefin_symbol($symbol);
            }
            if ($since !== null) {
                $request['startTimeAtMillis'] = $since;
            }
            if ($limit !== null) {
                $request['limit'] = $limit;
            }
            $response = Async\await($this->accountGetApiV1AccountTrades ($this->extend($request, $params)));
            $trades = (gettype($response) === 'array' && array_keys($response) === array_keys(array_keys($response))) ? $response : $this->safe_list($response, 'trades', array());
            // Group $trades by $orderHash
            $grouped = array();
            for ($i = 0; $i < count($trades); $i++) {
                $orderHash = $this->safe_string($trades[$i], 'orderHash');
                if ($orderHash === null) {
                    continue;
                }
                if ($grouped[$orderHash] === null) {
                    $grouped[$orderHash] = array();
                }
                $grouped[$orderHash][] = $trades[$i];
            }
            // Reconstruct one Order per unique $orderHash
            $result => Orderarray() = array();
            $orderHashes = is_array($grouped) ? array_keys($grouped) : array();
            for ($i = 0; $i < count($orderHashes); $i++) {
                $result[] = $this->reconstruct_order_from_trades($orderHashes[$i], $grouped[$orderHashes[$i]], $market);
            }
            return $result;
        }) ();
    }

    public function reconstruct_order_from_trades(string $id, array $trades, ?array $market = null): array {
        // Reconstruct a closed Order from its constituent trade fills.
        // All $trades share the same orderHash, $side, $symbol->
        $first = $trades[0];
        $bluefinSym = $this->safe_string($first, 'symbol');
        $symbol = ($bluefinSym !== null) ? $this->ccxt_symbol($bluefinSym) : null;
        $side = $this->parse_order_side($this->safe_string($first, 'side'));
        // Aggregate => total $filled qty, total $cost, total $fee, latest $timestamp
        $filledE9 = '0';
        $costE9 = '0';
        $feeE9 = '0';
        $lastTimestamp = 0;
        for ($i = 0; $i < count($trades); $i++) {
            $qtyStr = $this->safe_string($trades[$i], 'quantityE9', '0');
            $costStr = $this->safe_string($trades[$i], 'quoteQuantityE9', '0');
            $feeStr = $this->safe_string($trades[$i], 'tradingFeeE9', '0');
            $filledE9 = Precise::string_add($filledE9, $qtyStr);
            $costE9 = Precise::string_add($costE9, $costStr);
            $feeE9 = Precise::string_add($feeE9, $feeStr);
            $ts = $this->safe_integer($trades[$i], 'executedAtMillis', 0);
            if ($ts > $lastTimestamp) {
                $lastTimestamp = $ts;
            }
        }
        $filled = $this->parse_e9($filledE9);
        $cost = $this->parse_e9($costE9);
        $fee = $this->parse_e9($feeE9);
        // Average price = total $cost / total $filled qty
        $average = ($filledE9 !== '0') ? Precise::string_div($costE9, $filledE9) : null;
        $timestamp = $this->safe_integer($first, 'executedAtMillis');
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => null,
            'info' => $trades,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => $lastTimestamp,
            'symbol' => $symbol,
            'type' => null,
            'timeInForce' => null,
            'postOnly' => null,
            'reduceOnly' => null,
            'side' => $side,
            'price' => null,
            'amount' => null,
            'filled' => $filled,
            'remaining' => $this->parse_number('0'),
            'cost' => $cost,
            'average' => $average,
            'status' => 'closed',
            'fee' => array(
                'cost' => $this->parse_number($fee),
                'currency' => 'USDC',
            ),
            'trades' => null,
        ), $market);
    }

    public function create_order(string $symbol, string $type, string $side, float $amount, ?float $price = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $type, $side, $amount, $price, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $market = $this->market($symbol);
            $contractsConfig = $this->safe_dict($this->options, 'contractsConfig', array());
            $idsId = $this->safe_string($contractsConfig, 'idsId');
            if ($idsId === null) {
                throw new ArgumentsRequired($this->id . ' createOrder() requires $contractsConfig->idsId from fetchMarkets()');
            }
            $now = $this->milliseconds();
            $leverage = $this->safe_string($params, 'leverage', '1');
            $isIsolated = $this->safe_bool($params, 'isIsolated', false);
            $reduceOnly = $this->safe_bool($params, 'reduceOnly', false);
            $postOnly = $this->safe_bool($params, 'postOnly', false);
            $timeInForce = $this->safe_string($params, 'timeInForce');
            $clientOrderId = $this->safe_string($params, 'clientOrderId');
            $bluefinSide = ($side === 'buy') ? 'LONG' : 'SHORT';
            $priceStr = ($price !== null) ? $this->number_to_string($price) : '0';
            $amountStr = $this->number_to_string($amount);
            $priceE9 = $this->to_e9($priceStr);
            $quantityE9 = $this->to_e9($amountStr);
            $leverageE9 = $this->to_e9($leverage);
            $salt = $this->generate_salt();
            $expirationMs = $now + 86400000; // 24h
            $expiration = (string) $expirationMs;
            $signedAt = (string) $now;
            $uiPayload = array(
                'type' => 'Bluefin Pro Order',
                'ids' => $idsId,
                'account' => $this->walletAddress,
                'market' => $market['id'],
                'price' => $priceE9,
                'quantity' => $quantityE9,
                'leverage' => $leverageE9,
                'side' => $bluefinSide,
                'positionType' => $isIsolated ? 'ISOLATED' : 'CROSS',
                'expiration' => $expiration,
                'salt' => $salt,
                'signedAt' => $signedAt,
            );
            $signature = $this->sign_trade_request($uiPayload);
            $request = array(
                'signedFields' => array(
                    'symbol' => $market['id'],
                    'accountAddress' => $this->walletAddress,
                    'priceE9' => $priceE9,
                    'quantityE9' => $quantityE9,
                    'side' => $bluefinSide,
                    'leverageE9' => $leverageE9,
                    'isIsolated' => $isIsolated,
                    'salt' => $salt,
                    'idsId' => $idsId,
                    'expiresAtMillis' => $this->parse_to_int($expiration),
                    'signedAtMillis' => $now,
                ),
                'signature' => $signature,
                'type' => strtoupper($type),
                'reduceOnly' => $reduceOnly,
            );
            if ($postOnly) {
                $request['postOnly'] = true;
            }
            if ($timeInForce !== null) {
                $request['timeInForce'] = $timeInForce;
            }
            if ($clientOrderId !== null) {
                $request['clientOrderId'] = $clientOrderId;
            }
            $cleanParams = $this->omit($params, array( 'leverage', 'isIsolated', 'reduceOnly', 'postOnly', 'timeInForce', 'clientOrderId' ));
            $response = Async\await($this->tradePostApiV1TradeOrders ($this->extend($request, $cleanParams)));
            return $this->parse_order($response, $market);
        }) ();
    }

    public function cancel_order(string $id, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($id, $symbol, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $request = array(
                'orderHashes' => array( $id ),
            );
            if ($symbol !== null) {
                $request['symbol'] = $this->bluefin_symbol($symbol);
            }
            $response = Async\await($this->tradePutApiV1TradeOrdersCancel ($this->extend($request, $params)));
            return $this->safe_order(array(
                'id' => $id,
                'info' => $response,
                'status' => 'canceled',
            ));
        }) ();
    }

    public function cancel_orders(array $ids, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($ids, $symbol, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $request = array(
                'orderHashes' => $ids,
            );
            if ($symbol !== null) {
                $request['symbol'] = $this->bluefin_symbol($symbol);
            }
            $response = Async\await($this->tradePutApiV1TradeOrdersCancel ($this->extend($request, $params)));
            $cancelledHashes = $this->safe_list($response, 'orderHashes', $ids);
            $result => Orderarray() = array();
            for ($i = 0; $i < count($cancelledHashes); $i++) {
                $result[] = $this->safe_order(array(
                    'id' => $cancelledHashes[$i],
                    'info' => $response,
                    'status' => 'canceled',
                ));
            }
            return $result;
        }) ();
    }

    public function set_leverage(?int $leverage, ?string $symbol = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($leverage, $symbol, $params) {
            if ($symbol === null) {
                throw new ArgumentsRequired($this->id . ' setLeverage() requires a $symbol argument');
            }
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $market = $this->market($symbol);
            $contractsConfig = $this->safe_dict($this->options, 'contractsConfig', array());
            $idsId = $this->safe_string($contractsConfig, 'idsId');
            if ($idsId === null) {
                throw new ArgumentsRequired($this->id . ' setLeverage() requires $contractsConfig->idsId from fetchMarkets()');
            }
            $now = $this->milliseconds();
            $leverageE9 = $this->to_e9($this->number_to_string($leverage));
            $salt = $this->generate_salt();
            $signedAt = (string) $now;
            $uiPayload = array(
                'type' => 'Bluefin Pro Leverage Adjustment',
                'ids' => $idsId,
                'account' => $this->walletAddress,
                'market' => $market['id'],
                'leverage' => $leverageE9,
                'salt' => $salt,
                'signedAt' => $signedAt,
            );
            $signature = $this->sign_trade_request($uiPayload);
            $request = array(
                'signedFields' => array(
                    'accountAddress' => $this->walletAddress,
                    'symbol' => $market['id'],
                    'leverageE9' => $leverageE9,
                    'salt' => $salt,
                    'idsId' => $idsId,
                    'signedAtMillis' => $now,
                ),
                'signature' => $signature,
            );
            return Async\await($this->tradePutApiV1TradeLeverage ($this->extend($request, $params)));
        }) ();
    }

    public function set_margin_mode(string $marginMode, ?string $symbol = null, $params = array ()): PromiseInterface {
        // Bluefin sets margin $mode per-order via the isIsolated field.
        // Store the preference so createOrder can use it.
        $mode = strtolower($marginMode);
        if ($mode !== 'isolated' && $mode !== 'cross') {
            throw new ArgumentsRequired($this->id . ' setMarginMode() $marginMode must be "isolated" or "cross"');
        }
        $this->options['defaultMarginMode'] = $mode;
        return array( 'info' => $mode );
    }

    public function add_margin(string $symbol, float $amount, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $amount, $params) {
            return Async\await($this->adjust_margin($symbol, $amount, 'Add', $params));
        }) ();
    }

    public function reduce_margin(string $symbol, float $amount, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $amount, $params) {
            return Async\await($this->adjust_margin($symbol, $amount, 'Remove', $params));
        }) ();
    }

    public function adjust_margin(string $symbol, float $amount, string $operation, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbol, $amount, $operation, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $market = $this->market($symbol);
            $contractsConfig = $this->safe_dict($this->options, 'contractsConfig', array());
            $idsId = $this->safe_string($contractsConfig, 'idsId');
            if ($idsId === null) {
                throw new ArgumentsRequired($this->id . ' adjustMargin() requires $contractsConfig->idsId from fetchMarkets()');
            }
            $now = $this->milliseconds();
            $quantityE9 = $this->to_e9($this->number_to_string($amount));
            $salt = $this->generate_salt();
            $signedAt = (string) $now;
            $isAdd = ($operation === 'Add');
            $uiPayload = array(
                'type' => 'Bluefin Pro Margin Adjustment',
                'ids' => $idsId,
                'account' => $this->walletAddress,
                'market' => $market['id'],
                'add' => $isAdd,
                'amount' => $quantityE9,
                'salt' => $salt,
                'signedAt' => $signedAt,
            );
            $signature = $this->sign_trade_request($uiPayload);
            $request = array(
                'signedFields' => array(
                    'idsId' => $idsId,
                    'accountAddress' => $this->walletAddress,
                    'symbol' => $market['id'],
                    'operation' => $operation,
                    'quantityE9' => $quantityE9,
                    'salt' => $salt,
                    'signedAtMillis' => $now,
                ),
                'signature' => $signature,
            );
            return Async\await($this->tradePutApiV1TradeAdjustIsolatedMargin ($this->extend($request, $params)));
        }) ();
    }

    public function withdraw(string $code, float $amount, string $address, ?string $tag = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($code, $amount, $address, $tag, $params) {
            Async\await($this->load_markets());
            Async\await($this->get_access_token());
            $contractsConfig = $this->safe_dict($this->options, 'contractsConfig', array());
            $edsId = $this->safe_string($contractsConfig, 'edsId');
            if ($edsId === null) {
                throw new ArgumentsRequired($this->id . ' withdraw() requires $contractsConfig->edsId from fetchMarkets()');
            }
            $now = $this->milliseconds();
            $amountE9 = $this->to_e9($this->number_to_string($amount));
            $salt = $this->generate_salt();
            $signedAt = (string) $now;
            $uiPayload = array(
                'type' => 'Bluefin Pro Withdrawal',
                'eds' => $edsId,
                'assetSymbol' => $code,
                'account' => $this->walletAddress,
                'amount' => $amountE9,
                'salt' => $salt,
                'signedAt' => $signedAt,
            );
            $signature = $this->sign_trade_request($uiPayload);
            $request = array(
                'signedFields' => array(
                    'assetSymbol' => $code,
                    'accountAddress' => $this->walletAddress,
                    'amountE9' => $amountE9,
                    'salt' => $salt,
                    'edsId' => $edsId,
                    'signedAtMillis' => $now,
                ),
                'signature' => $signature,
            );
            return Async\await($this->tradePostApiV1TradeWithdraw ($this->extend($request, $params)));
        }) ();
    }

    public function parse_market(array $market): array {
        $id = $this->safe_string($market, 'symbol');
        $base = $this->safe_string($market, 'baseAssetSymbol');
        $quote = 'USDC';
        $settle = 'USDC';
        $symbol = $base . '/' . $quote . ':' . $settle;
        $status = $this->safe_string($market, 'status');
        return $this->safe_market_structure(array(
            'id' => $id,
            'symbol' => $symbol,
            'base' => $base,
            'quote' => $quote,
            'settle' => $settle,
            'baseId' => $base,
            'quoteId' => $quote,
            'settleId' => $settle,
            'type' => 'swap',
            'spot' => false,
            'margin' => false,
            'swap' => true,
            'future' => false,
            'option' => false,
            'contract' => true,
            'linear' => true,
            'inverse' => false,
            'active' => $status === 'ACTIVE',
            'taker' => $this->parse_number($this->parse_e9($this->safe_string($market, 'defaultTakerFeeE9'))),
            'maker' => $this->parse_number($this->parse_e9($this->safe_string($market, 'defaultMakerFeeE9'))),
            'contractSize' => $this->parse_number('1'),
            'precision' => array(
                'price' => $this->parse_number($this->parse_e9($this->safe_string($market, 'tickSizeE9'))),
                'amount' => $this->parse_number($this->parse_e9($this->safe_string($market, 'stepSizeE9'))),
            ),
            'limits' => array(
                'amount' => array(
                    'min' => $this->parse_number($this->parse_e9($this->safe_string($market, 'minOrderQuantityE9'))),
                    'max' => $this->parse_number($this->parse_e9($this->safe_string($market, 'maxLimitOrderQuantityE9'))),
                ),
                'price' => array(
                    'min' => $this->parse_number($this->parse_e9($this->safe_string($market, 'minOrderPriceE9'))),
                    'max' => $this->parse_number($this->parse_e9($this->safe_string($market, 'maxOrderPriceE9'))),
                ),
                'leverage' => array(
                    'min' => $this->parse_number('1'),
                    'max' => $this->parse_number($this->parse_e9($this->safe_string($market, 'defaultLeverageE9'))),
                ),
            ),
            'info' => $market,
        ));
    }

    public function parse_ticker(array $ticker, ?array $market = null): array {
        $bluefinSym = $this->safe_string($ticker, 'symbol');
        $symbol = ($bluefinSym !== null) ? $this->ccxt_symbol($bluefinSym) : null;
        $last = $this->parse_e9($this->safe_string($ticker, 'lastPriceE9'));
        $mark = $this->parse_e9($this->safe_string($ticker, 'markPriceE9'));
        $index = $this->parse_e9($this->safe_string($ticker, 'oraclePriceE9'));
        $high = $this->parse_e9($this->safe_string($ticker, 'highPrice24hrE9'));
        $low = $this->parse_e9($this->safe_string($ticker, 'lowPrice24hrE9'));
        $open = $this->parse_e9($this->safe_string($ticker, 'openPrice24hrE9'));
        $close = $last;
        $bid = $this->parse_e9($this->safe_string($ticker, 'bestBidPriceE9'));
        $ask = $this->parse_e9($this->safe_string($ticker, 'bestAskPriceE9'));
        $bidVolume = $this->parse_e9($this->safe_string($ticker, 'bestBidQuantityE9'));
        $askVolume = $this->parse_e9($this->safe_string($ticker, 'bestAskQuantityE9'));
        $baseVolume = $this->parse_e9($this->safe_string($ticker, 'volume24hrE9'));
        $quoteVolume = $this->parse_e9($this->safe_string($ticker, 'quoteVolume24hrE9'));
        $change = $this->parse_e9($this->safe_string($ticker, 'priceChange24hrE9'));
        $percentRaw = $this->parse_e9($this->safe_string($ticker, 'priceChangePercent24hrE9'));
        $percentage = Precise::string_mul($percentRaw, '100');
        $timestamp = $this->safe_integer($ticker, 'lastTimeAtMillis');
        return $this->safe_ticker(array(
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'high' => $high,
            'low' => $low,
            'bid' => $bid,
            'bidVolume' => $bidVolume,
            'ask' => $ask,
            'askVolume' => $askVolume,
            'vwap' => null,
            'open' => $open,
            'close' => $close,
            'last' => $last,
            'previousClose' => null,
            'change' => $change,
            'percentage' => $percentage,
            'average' => null,
            'baseVolume' => $baseVolume,
            'quoteVolume' => $quoteVolume,
            'markPrice' => $mark,
            'indexPrice' => $index,
            'mark' => $mark,
            'index' => $index,
            'info' => $ticker,
        ), $market);
    }

    public function parse_trade(array $trade, ?array $market = null): array {
        $id = $this->safe_string($trade, 'id');
        $bluefinSym = $this->safe_string($trade, 'symbol');
        $symbol = ($bluefinSym !== null) ? $this->ccxt_symbol($bluefinSym) : null;
        $price = $this->parse_e9($this->safe_string($trade, 'priceE9'));
        $amount = $this->parse_e9($this->safe_string($trade, 'quantityE9'));
        $cost = $this->parse_e9($this->safe_string($trade, 'quoteQuantityE9'));
        $side = $this->parse_order_side($this->safe_string($trade, 'side'));
        $timestamp = $this->safe_integer($trade, 'executedAtMillis');
        $orderId = $this->safe_string($trade, 'orderHash');
        $takerOrMaker = $this->safe_string_lower($trade, 'makerTaker');
        // Private trades include $fee info
        $fee = null;
        $feeE9 = $this->safe_string($trade, 'tradingFeeE9');
        if ($feeE9 !== null) {
            $fee = array(
                'cost' => $this->parse_number($this->parse_e9($feeE9)),
                'currency' => 'USDC',
            );
        }
        return $this->safe_trade(array(
            'id' => $id,
            'info' => $trade,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'symbol' => $symbol,
            'order' => $orderId,
            'type' => null,
            'side' => $side,
            'takerOrMaker' => $takerOrMaker,
            'price' => $price,
            'amount' => $amount,
            'cost' => $cost,
            'fee' => $fee,
        ), $market);
    }

    public function parse_order(array $order, ?array $market = null): array {
        $id = $this->safe_string($order, 'orderHash');
        $clientOrderId = $this->safe_string($order, 'clientOrderId');
        $bluefinSym = $this->safe_string($order, 'symbol');
        $symbol = ($bluefinSym !== null) ? $this->ccxt_symbol($bluefinSym) : null;
        $rawType = $this->safe_string_lower($order, 'type');
        $side = $this->parse_order_side($this->safe_string($order, 'side'));
        $price = $this->parse_e9($this->safe_string($order, 'priceE9'));
        $amount = $this->parse_e9($this->safe_string($order, 'quantityE9'));
        $filled = $this->parse_e9($this->safe_string($order, 'filledQuantityE9'));
        $status = $this->parse_order_status($this->safe_string($order, 'status'));
        $timeInForce = $this->safe_string($order, 'timeInForce');
        $postOnly = $this->safe_bool($order, 'postOnly');
        $reduceOnly = $this->safe_bool($order, 'reduceOnly');
        $timestamp = $this->safe_integer($order, 'orderTimeAtMillis');
        return $this->safe_order(array(
            'id' => $id,
            'clientOrderId' => $clientOrderId,
            'info' => $order,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'lastTradeTimestamp' => null,
            'symbol' => $symbol,
            'type' => $rawType,
            'timeInForce' => $timeInForce,
            'postOnly' => $postOnly,
            'reduceOnly' => $reduceOnly,
            'side' => $side,
            'price' => $price,
            'amount' => $amount,
            'filled' => $filled,
            'remaining' => null,
            'cost' => null,
            'average' => null,
            'status' => $status,
            'fee' => null,
            'trades' => null,
        ), $market);
    }

    public function parse_position(array $position, ?array $market = null): array {
        $bluefinSym = $this->safe_string($position, 'symbol');
        $symbol = ($bluefinSym !== null) ? $this->ccxt_symbol($bluefinSym) : null;
        $rawSide = $this->safe_string($position, 'side');
        $side = ($rawSide !== null) ? strtolower($rawSide) : null;
        $contracts = $this->parse_number($this->parse_e9($this->safe_string($position, 'sizeE9')));
        $entryPrice = $this->parse_number($this->parse_e9($this->safe_string($position, 'avgEntryPriceE9')));
        $markPrice = $this->parse_number($this->parse_e9($this->safe_string($position, 'markPriceE9')));
        $liquidationPrice = $this->parse_number($this->parse_e9($this->safe_string($position, 'liquidationPriceE9')));
        $notional = $this->parse_number($this->parse_e9($this->safe_string($position, 'notionalValueE9')));
        $unrealizedPnl = $this->parse_number($this->parse_e9($this->safe_string($position, 'unrealizedPnlE9')));
        $initialMargin = $this->parse_number($this->parse_e9($this->safe_string($position, 'marginRequiredE9')));
        $maintenanceMargin = $this->parse_number($this->parse_e9($this->safe_string($position, 'maintenanceMarginE9')));
        $leverage = $this->parse_number($this->parse_e9($this->safe_string($position, 'clientSetLeverageE9')));
        $isIsolated = $this->safe_bool($position, 'isIsolated');
        $marginMode = $isIsolated ? 'isolated' : 'cross';
        $collateral = $isIsolated ? $this->parse_number($this->parse_e9($this->safe_string($position, 'isolatedMarginE9'))) : $initialMargin;
        $timestamp = $this->safe_integer($position, 'updatedAtMillis');
        return $this->safe_position(array(
            'id' => null,
            'symbol' => $symbol,
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
            'contracts' => $contracts,
            'contractSize' => null,
            'side' => $side,
            'notional' => $notional,
            'leverage' => $leverage,
            'unrealizedPnl' => $unrealizedPnl,
            'realizedPnl' => null,
            'collateral' => $collateral,
            'entryPrice' => $entryPrice,
            'markPrice' => $markPrice,
            'liquidationPrice' => $liquidationPrice,
            'marginMode' => $marginMode,
            'hedged' => null,
            'maintenanceMargin' => $maintenanceMargin,
            'maintenanceMarginPercentage' => null,
            'initialMargin' => $initialMargin,
            'initialMarginPercentage' => null,
            'marginRatio' => null,
            'percentage' => null,
            'stopLossPrice' => null,
            'takeProfitPrice' => null,
            'info' => $position,
        ));
    }

    public function parse_balance(array $response): array {
        $result = array( 'info' => $response );
        $assets = $this->safe_list($response, 'assets', array());
        for ($i = 0; $i < count($assets); $i++) {
            $asset = $assets[$i];
            $code = $this->safe_string($asset, 'symbol');
            $account = $this->account();
            $account['total'] = $this->parse_e9($this->safe_string($asset, 'quantityE9'));
            $account['free'] = $this->parse_e9($this->safe_string($asset, 'effectiveBalanceE9'));
            $result[$code] = $account;
        }
        return $this->safe_balance($result);
    }

    public function parse_ohlcv(mixed $ohlcv, ?array $market = null): array {
        // Bluefin returns candlesticks of strings:
        //   [startTime, open, high, low, close, volume,
        //    endTime, quoteVolume, tradeCount]
        // Price and volume values are in E9 format (multiply by 1e-9).
        return array(
            $this->safe_integer($ohlcv, 0),
            $this->parse_number($this->parse_e9($this->safe_string($ohlcv, 1))),
            $this->parse_number($this->parse_e9($this->safe_string($ohlcv, 2))),
            $this->parse_number($this->parse_e9($this->safe_string($ohlcv, 3))),
            $this->parse_number($this->parse_e9($this->safe_string($ohlcv, 4))),
            $this->parse_number($this->parse_e9($this->safe_string($ohlcv, 5))),
        );
    }

    public function parse_funding_rate_history(array $entry, ?array $market = null): FundingRateHistory {
        $bluefinSym = $this->safe_string($entry, 'symbol');
        $symbol = ($bluefinSym !== null) ? $this->ccxt_symbol($bluefinSym) : null;
        $fundingRate = $this->parse_e9($this->safe_string($entry, 'fundingRateE9'));
        $timestamp = $this->safe_integer($entry, 'fundingTimeAtMillis');
        return array(
            'info' => $entry,
            'symbol' => $symbol,
            'fundingRate' => $this->parse_number($fundingRate),
            'timestamp' => $timestamp,
            'datetime' => $this->iso8601($timestamp),
        );
    }

    public function parse_order_status(?string $status): string {
        $statuses = array(
            'PENDING' => 'open',
            'STANDBY' => 'open',
            'OPEN' => 'open',
            'PARTIAL_FILLED' => 'open',
            'PARTIALLY_FILLED_OPEN' => 'open',
            'FILLED' => 'closed',
            'CANCELLED' => 'canceled',
            'CANCELLING' => 'canceled',
            'PARTIALLY_FILLED_CANCELED' => 'canceled',
            'EXPIRED' => 'canceled',
            'PARTIALLY_FILLED_EXPIRED' => 'canceled',
            'REJECTED' => 'rejected',
        );
        return $this->safe_string($statuses, $status, $status);
    }

    public function parse_order_side(?string $side): string {
        $sides = array(
            'LONG' => 'buy',
            'SHORT' => 'sell',
            'BUY' => 'buy',
            'SELL' => 'sell',
        );
        return $this->safe_string($sides, $side, $side);
    }

    public function fetch_leverage_tiers(?array $symbols = null, $params = array ()): PromiseInterface {
        return Async\async(function () use ($symbols, $params) {
            Async\await($this->load_markets());
            $symbols = $this->market_symbols($symbols);
            $result => LeverageTiers = array();
            $marketIds = is_array($this->markets) ? array_keys($this->markets) : array();
            for ($i = 0; $i < count($marketIds); $i++) {
                $market = $this->markets[$marketIds[$i]];
                if (!$market['swap']) {
                    continue;
                }
                $symbol = $market['symbol'];
                if ($symbols !== null && !$this->in_array($symbol, $symbols)) {
                    continue;
                }
                $tiers = $this->parse_market_leverage_tiers($market['info'], $market);
                if (strlen($tiers) > 0) {
                    $result[$symbol] = $tiers;
                }
            }
            return $result;
        }) ();
    }

    public function parse_market_leverage_tiers(array $info, ?array $market = null): array {
        // $maxNotionalAtOpenE9 is an array where index $i = max open notional
        // at leverage ($i+1)x. Higher leverage → lower max notional.
        // CCXT convention => $tiers are sorted by ascending notional range,
        // each tier specifying the max leverage allowed at that notional bracket.
        // So we invert => highest leverage (last valid entry) → lowest notional → tier 1.
        $maxNotionalAtOpenE9 = $this->safe_list($info, 'maxNotionalAtOpenE9', array());
        $maintenanceMarginRatioE9 = $this->safe_string($info, 'maintenanceMarginRatioE9');
        $mmr = ($maintenanceMarginRatioE9 !== null) ? $this->parse_number($this->parse_e9($maintenanceMarginRatioE9)) : null;
        // Collect valid (leverage, $maxNotional) pairs, filter zeros
        $validPairs => Dictarray() = array();
        for ($i = 0; $i < count($maxNotionalAtOpenE9); $i++) {
            $idx = strlen($maxNotionalAtOpenE9) - 1 - $i;
            $maxNotionalStr = $this->safe_string($maxNotionalAtOpenE9, $idx);
            if ($maxNotionalStr === null || $maxNotionalStr === '0') {
                continue;
            }
            $maxNotional = $this->parse_number($this->parse_e9($maxNotionalStr));
            $validPairs[] = array(
                'leverage' => $idx + 1,
                'maxNotional' => $maxNotional,
                'maxNotionalE9' => $maxNotionalStr,
            );
        }
        // $validPairs is now highest-leverage-first (smallest notional first) — exactly what we need
        $tiers = array();
        for ($i = 0; $i < count($validPairs); $i++) {
            $pair = $validPairs[$i];
            $minNotional = ($i === 0) ? 0 : $validPairs[$i - 1]['maxNotional'];
            $tierSymbol = ($market !== null) ? $market['symbol'] : null;
            $tiers[] = array(
                'tier' => $i + 1,
                'symbol' => $tierSymbol,
                'currency' => 'USDC',
                'minNotional' => $minNotional,
                'maxNotional' => $pair['maxNotional'],
                'maintenanceMarginRate' => $mmr,
                'maxLeverage' => $pair['leverage'],
                'info' => array(
                    'maxNotionalE9' => $pair['maxNotionalE9'],
                    'leverage' => $pair['leverage'],
                ),
            );
        }
        return $tiers;
    }

    public function sign(string $path, $api = 'public', $method = 'GET', array $params = array (), mixed $headers = null, mixed $body = null): array {
        $url = $this->urls['api'][$api] . '/' . $path;
        if ($api === 'exchange') {
            if ($method === 'GET') {
                if ($params) {
                    $url .= '?' . $this->urlencode($params);
                }
            } else {
                $headers = array( 'Content-Type' => 'application/json' );
                $body = $this->json($params);
            }
        } elseif ($api === 'auth') {
            // Auth endpoints => route $payloadSignature from $params to header
            $payloadSignature = $this->safe_string($params, 'payloadSignature');
            $cleanParams = $this->omit($params, array( 'payloadSignature' ));
            $headers = array( 'Content-Type' => 'application/json' );
            if ($payloadSignature !== null) {
                $headers['payloadSignature'] = $payloadSignature;
            }
            if ($method === 'GET') {
                if ($cleanParams) {
                    $url .= '?' . $this->urlencode($cleanParams);
                }
            } else {
                $body = $this->json($cleanParams);
            }
        } else {
            // Private endpoints (account, trade) => attach JWT bearer $token
            $token = $this->safe_string($this->options, 'accessToken');
            $headers = array( 'Content-Type' => 'application/json' );
            if ($token !== null) {
                $headers['Authorization'] = 'Bearer ' . $token;
            }
            if ($method === 'GET') {
                if ($params) {
                    $url .= '?' . $this->urlencode($params);
                }
            } else {
                $body = $this->json($params);
            }
        }
        return array( 'url' => $url, 'method' => $method, 'body' => $body, 'headers' => $headers );
    }

    public function parse_e9(?string $value): ?string {
        if ($value === null) {
            return null;
        }
        $precise = new Precise ($value);
        $precise->decimals = $precise->decimals + 9;
        $precise->reduce ();
        return (string) $precise;
    }

    public function to_e9(?string $value): ?string {
        if ($value === null) {
            return null;
        }
        $precise = new Precise ($value);
        $precise->decimals = $precise->decimals - 9;
        $precise->reduce ();
        return (string) $precise;
    }

    public function convert_e9_levels($levels) {
        $result = array();
        for ($i = 0; $i < count($levels); $i++) {
            $level = $levels[$i];
            $result[] = array(
                $this->parse_e9($this->safe_string($level, 0)),
                $this->parse_e9($this->safe_string($level, 1)),
            );
        }
        return $result;
    }

    public function bluefin_symbol(string $ccxtSymbol): string {
        // "ETH/USDC:USDC" → "ETH-PERP"
        $market = $this->market($ccxtSymbol);
        return $market['base'] . '-PERP';
    }

    public function ccxt_symbol(string $bluefinSymbol): string {
        // "ETH-PERP" → "ETH/USDC:USDC"
        $base = str_replace('-PERP', '', $bluefinSymbol);
        return $base . '/USDC:USDC';
    }
}
